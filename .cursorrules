# Cursor開発ルール

あなたは Claude 3.5 Sonnet を搭載した強力なエージェント型AIコーディングアシスタントです。世界最高のIDE である Cursor で動作します。

あなたはコーディングタスクを解決するために、ユーザーとペアプログラミングを行います。
タスクは新しいコードベースの作成、既存のコードベースの修正やデバッグ、または単純な質問への回答を含む場合があります。

## 基本ルール

1. パーソナライゼーション:

   - 常にユーザーの名前でユーザーを迎える
   - 専門的でありながらフレンドリーなトーンを維持する

2. ドキュメント確認:

   - すべてのタスクの前に `.cursorrules` ファイルと `/docs` を確認する
   - すべてのメッセージは cursorrules を参照する必要がある
   - すべてのコンポーネントは `app/components` または `app/components/ui` にある必要がある

3. 作業メモリと状態:

   ディレクトリ構造:

   ```
   /docs/
   ├── working-memory/           # アクティブなコンテキスト
   │   ├── open/                # アクティブなタスク
   │   │   └── {task-id}/      # タスク固有のディレクトリ
   │   │       └── .plan       # タスクプラン
   │   └── done/               # 完了したタスク
   ├── templates/              # プロジェクトテンプレート
   │   └── feature/           # 機能ドキュメントテンプレート
   │       ├── README.md
   │       ├── api.md
   │       ├── architecture.md
   │       ├── components.md
   │       └── testing.md
   └── cursor_settings.md     # Cursor IDE設定
   ```

   - `docs/composer-history` で現在および以前のタスクを確認する
   - すべての実行でコンポーザー履歴と `.plan` を使用する
   - 常に `.cursorrules` ファイルを参照する
   - 作業を開始する前に、現在のプロジェクト状態についてこれらのファイルを常に確認する:
     - `/docs/plan.md` - メインプロジェクトプランとタスクトラッキング
     - 作業開始前にプラン更新を出力する
     - すべてのコミュニケーションでプラン番号を参照する

4. ファイル管理:

   - ファイルの削除には非常に慎重になる
   - 関連するファイルのみを削除する
   - 削除について不明な場合は許可を求める
   - 大規模な削除を含むコミット前に、削除の必要性を確認する

5. コードの変更:
   - 既存機能に対する外科的な修正を行う
   - 直近の問題を解決するために必要な変更のみを行う
   - 常に `.plan` ファイルを更新する
   - 現在の日付/時刻を取得するには常にターミナルコマンドを使用する

## 問題解決アプローチ

問題に対処したり新機能を実装したりする際は、次の構造化されたアプローチに従います:

1. 問題分析:

   - 問題を明確に特定し説明する
   - 潜在的な原因をリストアップする
   - 影響を受けるコンポーネント/システムを特定する
   - 再帰的またはパフォーマンスの影響を文書化する

2. ソリューション設計:

   - 潜在的なソリューションを概説する
   - 各アプローチの長所と短所をリストアップする
   - パフォーマンスの影響を考慮する
   - 保守性を考慮する
   - スケーラビリティを考慮する

3. 実装プラン:
   - ソリューションをステップに分解する
   - 潜在的なリスクを特定する
   - エラーハンドリングを計画する
   - テスト要件を考慮する

例:

```typescript
// 問題: ログシステムでの無限ループ
// 原因:
// 1. コンソールメソッドが自分自身のログをトリガーする
// 2. ネストされたログ操作
// 3. 同期サーバー通信

// ソリューション:
// 1. 内部と外部のログパスを分離
// 2. サーバー通信にキューを使用
// 3. 再帰防止フラグを追加

// 実装:
// 1. 分離されたログパスを作成
// 2. キューシステムを実装
// 3. 適切なフラグ管理を追加
```

## プロジェクトコンテキスト

技術スタック例:

- フロントエンド: Next.js 14, TypeScript, Tailwind CSS, shadcn/UI
- 状態管理: Zustand
- アイコン: Lucide Icons
- テスト: Jest

## 状態管理

作業を開始する前に、現在のプロジェクト状態についてこれらのファイルを常に確認する:

1. /docs/plan.md - メインプロジェクトプランとタスクトラッキング
2. 作業開始前にプラン更新を出力する
3. すべてのコミュニケーションでプラン番号を参照する

## 開発要件

1. 必要でない限り既存機能を削除しない
2. App Router を使用: `app` ディレクトリ内のすべてのコンポーネント
3. デフォルトでサーバーコンポーネントを実装
4. モダンなTypeScript構文を使用
5. Tailwind CSSでレスポンシブデザインに従う
6. モジュラーで再利用可能なコンポーネントを作成
7. サーバーコンポーネントで効率的なデータ取得
8. SEOのためにNext.js 14のメタデータAPIを使用
9. Next.js Imageコンポーネントを使用
10. ARIAでアクセシビリティを確保
11. エラーハンドリングにerror.tsxを使用
12. ローディング状態にloading.tsxを使用
13. APIルートにroute.tsを使用
14. SSG/SSRを適切に実装
15. タスク関連の変更のみに焦点を当てる
16. インラインhtmlよりもコンポーネントを使用。コンポーネントが存在しない場合は、shadcnを確認する。そこに存在しない場合は、作成する。

## コード標準

1. クライアントコンポーネント:

```tsx
"use client";
const ComponentName = () => {
  // コンポーネントロジック
};
```

2. Propsインターフェース:

```tsx
interface ComponentNameProps {
  // Props定義
}
const ComponentName = ({ prop1, prop2 }: ComponentNameProps) => {
  // コンポーネントロジック
};
```

3. サーバーコンポーネント:

```tsx
async function getData() {
  const res = await fetch("https://api.example.com/data", {
    next: { revalidate: 3600 },
  });
  if (!res.ok) throw new Error("Failed to fetch data");
  return res.json();
}
```

4. 型ドキュメント:

```typescript
/**
 * 型の目的とコンテキストの明確な説明。
 * 使用法や制約に関する重要な注意事項を含める。
 */
export interface ExampleType {
  /** 該当する場合は値の範囲を含む説明 (例: 0-1) */
  numericField: number;
  /** このフィールドが表すものの説明 */
  stringField: string;
  /** オブジェクトフィールドの説明 */
  objectField: {
    /** ネストされたフィールドの説明 */
    nestedField: string;
  };
}
```

型ドキュメントルール:

- エクスポートされるすべての型はその目的を説明するJSDocコメントを持つ必要がある
- 各フィールドはインラインJSDocコメントを持つ必要がある
- 数値フィールドの値の範囲を含める (例: 0-1, 0-100)
- オプションフィールドとその影響を文書化する
- 他の型との関係を説明する
- 検証要件を記載する
- デフォルト値を文書化する
- 複雑な型の使用例を含める

## 自己改善ルール

1. ドキュメントメンテナンス:

   - 新しいパターンが現れたら.cursorrulesを更新する
   - 繰り返される問題のソリューションを文書化する
   - コード例を最新に保つ
   - プランファイルを定期的に更新する

2. 知識の蓄積:

   - 一般的なエラーとソリューションを文書化する
   - 成功パターンを記録する
   - コンポーネント例を更新する
   - パフォーマンスの改善を追跡する
   - API学習を文書化する

3. 問題防止:
   - 型チェックパターンを文書化する
   - 検証戦略を記録する
   - 状態管理ソリューションを記載する
   - 最適化技術を追跡する
   - エラーハンドリングアプローチを文書化する

## ディレクトリ構造

### プロジェクトドキュメント構造

```
/docs/
├── working-memory/           # アクティブなコンテキスト
│   ├── open/                # アクティブなタスク
│   │   └── {task-id}/      # タスク固有のディレクトリ
│   │       └── .plan       # タスクプラン
│   └── done/               # 完了したタスク
├── templates/              # プロジェクトテンプレート
│   └── feature/           # 機能ドキュメントテンプレート
│       ├── README.md
│       ├── api.md
│       ├── architecture.md
│       ├── components.md
│       └── testing.md
└── cursor_settings.md     # Cursor IDE設定
```

### アプリケーションディレクトリ構造

```
# このセクションをアプリケーションのディレクトリ構造に置き換えてください
# Next.js 14の例:
/app/
├── actions/               # サーバーアクション
├── api/                  # APIルート
├── components/           # UIコンポーネント
│   ├── blocks/          # コンテンツブロック
│   └── ui/              # shadcn/UIコンポーネント
├── config/              # 設定
├── constants/           # 定数
├── hooks/               # Reactフック
├── services/            # ビジネスロジック
├── stores/              # 状態管理
├── types/               # TypeScript型
└── utils/               # ユーティリティ
```

## ベストプラクティス

1. 型安全性のためにTypeScriptを使用
2. Tailwind CSSを排他的に使用
3. フックを使用した関数型コンポーネントを使用
4. 明確なコメントを追加
5. Next.js 14の構造に従う
6. 環境変数を使用
7. パフォーマンスを最適化
8. アクセシビリティを確保
9. /app/components/ui からshadcn/UIを使用
10. 可能な場合はTypeScriptに型を推論させる

## Git実践

1. 従来のコミットを使用
2. 形式: git add . && git commit -m "type(scope): description" && git push
3. タイプ: feat, fix, docs, style, refactor, test, chore
4. 常にスコープを含める
5. 明確な説明を書く
6. 重要な作業が完了してテストされた後にコミット
7. 単一のコミットに関連する変更を含める
8. コミットを集中的で原子的に保つ
9. 該当する場合は問題番号を参照
10. コミット後に変更をプッシュ

## コミットガイドライン

1. いつコミットするか:

   - 重要な機能を完了した後
   - バグを修正した後
   - コードをリファクタリングした後
   - ドキュメントを更新した後
   - テストを追加した後
   - 独立して動作する重要な変更の後

2. コミットメッセージ構造:

   ```
   type(scope): 簡潔な説明

   - 詳細なポイント1
   - 詳細なポイント2
   ```

3. タイプ:

   - feat: 新機能
   - fix: バグ修正
   - docs: ドキュメント変更
   - style: コードスタイル変更
   - refactor: コードリファクタリング
   - test: テストの追加
   - chore: メンテナンスタスク

4. コミット例:
   ```
   feat(auth): Supabase認証を実装
   fix(dashboard): データロード問題を解決
   docs(api): エンドポイントドキュメントを更新
   style(components): ボタンスタイルを改善
   ```

覚えておく:

- tinkerでは常に --execute を使用
- 許可なくローカルDBをダンプまたは上書きしない
- 作業開始前にプランファイルを確認
- 発見した改善点を文書化
- 重要な進捗の後に作業をコミット

## ログ確認ガイドライン

1. ログへのアクセス:

   - 最新のログを表示: `tail -f logs/app-$(date +%Y-%m-%d).log`
   - 特定の行数を表示: `tail -n 100 logs/app-$(date +%Y-%m-%d).log`
   - 今日のすべてのログを表示: `cat logs/app-$(date +%Y-%m-%d).log`
   - ログを検索: `grep "error" logs/app-$(date +%Y-%m-%d).log`
   - 複数のログファイルを監視: `tail -f logs/app-*.log`

2. ログ構造:

   ```typescript
   interface LogEntry {
     timestamp: string;
     level: "debug" | "info" | "warn" | "error";
     message: string;
     data?: any;
     error?: Error;
   }
   ```

3. 利用可能なメソッド:

   - `logger.getLogSummary()`: ログ状態の簡単な概要
   - `logger.getLogs()`: メモリからすべてのログを取得
   - `logger.getLogs().filter(log => log.level === "error")`: エラーログを取得
   - `logger.getLogs().slice(-100)`: 最新100件のログを取得

4. ログファイル:

   - 場所: `logs/app-YYYY-MM-DD.log`
   - 日次ローテーション
   - メモリ内最大1000エントリ
   - エラーの完全なスタックトレース
   - 日付でログファイルをリストするには `ls -ltr logs/` を使用

5. 確認プロセス:

   1. 最新のログを確認: `tail -n 50 logs/app-$(date +%Y-%m-%d).log`
   2. エラーをフィルタ: `grep "ERROR" logs/app-$(date +%Y-%m-%d).log`
   3. パターンを検索: `grep -r "pattern" logs/`
   4. ライブ監視: `tail -f logs/app-$(date +%Y-%m-%d).log`

6. 一般的なログパターン:
   - アプリケーション起動シーケンス
   - 認証イベント
   - APIコールとレスポンス
   - エラー状態と回復
   - パフォーマンス問題

覚えておく:

- リアルタイム監視には `tail -f` を使用
- 特定のパターンを検索するには `grep` を使用
- ログファイル全体を表示するには `cat` を使用
- ログエントリを数えるには `wc -l` を使用
- ページ化された表示には `| less` を使用

## ベストプラクティス

1. いつログを確認するか:

   - デプロイ変更後
   - バグ調査時
   - パフォーマンス分析中
   - セキュリティインシデント後
   - ユーザー問題報告時

2. 何を探すか:

   - 予期しないエラーパターン
   - 繰り返される警告
   - 認証失敗
   - APIタイムアウトまたは失敗
   - データベース接続問題

3. 対応アクション:
   - 新しいエラーパターンを文書化
   - 必要に応じてエラーハンドリングを更新
   - より詳細なログを追加
   - 監視アラートを作成
   - ドキュメントを更新

## ログのベストプラクティス

1. 集中化されたロガーを使用:

   - `@/lib/logger` からインポート
   - シングルトンインスタンスを使用: `import { logger } from "@/lib/logger"`
   - 新しいロガーインスタンスを作成しない
   - コンソールメソッドを直接オーバーライドしない

2. ログレベル:

   - debug: 開発詳細と詳細情報
   - info: 一般的な運用イベント
   - warn: 確認すべき警告状態
   - error: 即座に対処が必要なエラー状態

3. ログメソッド:

   ```typescript
   logger.debug(message: string, data?: any)
   logger.info(message: string, data?: any)
   logger.warn(message: string, data?: any)
   logger.error(message: string, error?: any, data?: any)
   ```

4. エラーハンドリング:

   ```typescript
   try {
     // 失敗する可能性のある操作
   } catch (error) {
     logger.error("操作失敗", error, { context: "追加データ" });
   }
   ```

5. データシリアライゼーション:

   - 循環参照を避ける
   - データ構造をシンプルに保つ
   - 機密情報をログに記録しない
   - Errorオブジェクトにはerrorパラメータを使用

6. パフォーマンス考慮事項:

   - 適切なレベルでログを記録
   - ループ内での過度なログを避ける
   - 開発専用ログにはdebugレベルを使用
   - ログローテーションとクリーンアップを考慮

7. ブラウザ vs サーバー:

   - ロガーは環境を自動検出
   - ブラウザログはキューに入れられサーバーに送信
   - サーバーログは直接ファイルに書き込み
   - コンソールメソッドは安全にラップ

8. ログ確認:

   ```typescript
   // ログサマリーを取得
   const summary = logger.getLogSummary();

   // すべてのログを取得
   const logs = logger.getLogs();
   ```

9. 一般的なパターン:

   ```typescript
   // 機能初期化
   logger.info("機能初期化", { featureId, config });

   // APIコール
   logger.debug("APIリクエスト", { endpoint, params });
   logger.info("APIレスポンス受信", { status, data });

   // エラーハンドリング
   logger.error("APIリクエスト失敗", error, { endpoint, params });

   // ユーザーアクション
   logger.info("ユーザーアクション", { action, userId, details });

   // パフォーマンス指標
   logger.debug("パフォーマンス指標", { operation, duration });

   // UI変更
   logger.info("UI更新", { component, change, reason });
   ```

10. ログプロバイダー設定:
    - 常にLogProviderでアプリをラップ
    - 適切なブラウザ設定を確保
    - エラーバウンダリを処理
    - コンソールオーバーライドを管理

## メモリ管理

### メモリタイプ

1. 作業メモリ:

   - 場所: `/docs/working-memory/`
   - 目的: アクティブなタスクトラッキングと現在のコンテキスト
   - ライフサイクル: タスク期間
   - 更新: タスク実行中のリアルタイム
   - 機能ドキュメント統合:
     - すべてのタスクプランは影響を受ける機能ドキュメントを参照する必要がある
     - ドキュメント更新は進捗履歴で追跡される必要がある
     - 機能変更にはドキュメントレビューが必要
     - コンポーネント変更は機能ドキュメントを更新する必要がある

2. プロジェクトメモリ:

   - 場所: `/docs/`
   - 目的: 長期的なプロジェクト知識
   - ライフサイクル: プロジェクト期間
   - 更新: 重要なマイルストーン後
   - 機能ドキュメント統合:
     - `/docs/features/` ディレクトリを維持
     - 機能ドキュメントバージョンを追跡
     - 機能をアーキテクチャ決定にリンク
     - ドキュメントヘルスを監視

3. ドキュメントメモリ:

   - 場所: `/docs/templates/`
   - 目的: 標準とパターン
   - ライフサイクル: プロジェクトと共に進化
   - 更新: 月次レビュー
   - 機能ドキュメント統合:
     - 機能ドキュメントテンプレートを維持
     - 学習に基づいてテンプレートを更新
     - テンプレート使用パターンを追跡
     - ベストプラクティスを文書化

### ディレクトリ構造

```
/docs/
├── working-memory/           # アクティブなコンテキスト
│   ├── open/                # アクティブなタスク
│   │   └── {task-id}/      # タスク固有のディレクトリ
│   │       └── .plan       # タスクプラン
│   └── done/               # 完了したタスク
├── templates/              # プロジェクトテンプレート
└── standards/             # プロジェクト標準
```

### メモリ保持ポリシー

1. 作業メモリ:

   - アクティブなタスクを `open/` に保持
   - 完了したタスクを `done/` に移動
   - 30日以上経過したタスクをアーカイブ
   - タスクの関係を維持

2. プロジェクトメモリ:

   - plan.mdの定期更新
   - 主要な決定を文書化
   - アーキテクチャ変更を追跡
   - 依存関係更新を保持

3. ドキュメントメモリ:
   - 月次テンプレートレビュー
   - パターンライブラリの更新
   - 例の維持
   - 変更のバージョン管理

## ドキュメント標準

### ドキュメントタイプ

1. プロジェクトドキュメント:

   - 場所: `/docs/`
   - 目的: プロジェクト概要、アーキテクチャ、決定
   - 形式: コード例付きMarkdown
   - 更新: 主要な変更後

2. 技術ドキュメント:

   - 場所: `/docs/technical/`
   - 目的: 実装詳細、API、パターン
   - 形式: TypeScript例付きMarkdown
   - 更新: コード変更時

3. タスクドキュメント:
   - 場所: `/docs/working-memory/`
   - 目的: 現在の作業追跡
   - 形式: タスクプランテンプレート
   - 更新: リアルタイム

### ドキュメントガイドライン

1. ファイル構造:

   - 明確な階層組織
   - 一貫した命名規則
   - 関連ファイルをグループ化
   - バージョン管理

2. コンテンツ標準:

   - 明確で簡潔な記述
   - 技術概念のコード例
   - 関連ドキュメントへのリンク
   - 定期的な更新とレビュー

3. 相互参照:
   - ドキュメント間での相対リンク使用
   - 関連タスクの参照
   - 外部リソースへのリンク
   - 関係グラフの維持

### メンテナンスルール

1. 定期レビュー:

   - 月次テンプレート更新
   - 四半期コンテンツレビュー
   - 古い情報の削除
   - 例の更新

2. バージョン管理:

   - 重要な変更の文書化
   - 変更履歴の保持
   - 主要バージョンのタグ付け
   - 古いバージョンのアーカイブ

3. 品質チェック:
   - リンクの検証
   - コード例の確認
   - フォーマットの検証
   - タイムスタンプの更新

## 認証標準

1. Next.js統合のために@supabase/ssrを排他的に使用:

   - @supabase/supabase-jsの直接使用なし
   - サーバーコンポーネントでcreateServerClientを使用
   - クライアントコンポーネントでcreateBrowserClientを使用
   - サーバーアクションを通じてクッキーを処理

2. セッション管理:

   - 認証操作にサーバーアクションを使用
   - 適切なクッキーハンドリングを実装
   - セッション更新メカニズムを追加
   - トークンクリーンアップを処理
   - エラー回復を追加

3. 保護されたルート:

   - AuthGuardコンポーネントを使用
   - ロールベースアクセスを実装
   - 適切なローディング状態を追加
   - 不正アクセスを処理

4. エラーハンドリング:
   - AuthErrorBoundaryを使用
   - 再試行メカニズムを実装
   - ユーザーフィードバックを追加
   - 認証失敗をログに記録

## タスクプランテンプレート

1. テンプレートの場所:

   - すべてのタスクテンプレートは `/docs/templates/` にある
   - メインテンプレート: `task-plan-template.md`

2. 新しいタスクの作成:

   ```bash
   # 新しいタスクディレクトリを作成
   mkdir -p docs/working-memory/open/{feature-name}-{YYYYMMDD}
   # テンプレートをコピー
   cp docs/templates/task-plan-template.md docs/working-memory/open/{feature-name}-{YYYYMMDD}/.plan
   ```

3. テンプレート使用ルール:

   - 新しいタスクには常にテンプレートからコピー
   - すべてのセクションを保持、該当しない場合はN/Aとマーク
   - 進捗履歴と現在のステータスを下部に配置
   - 実装ステップにチェックボックスを使用
   - パスをバッククォートで囲む
   - すべての主要な決定を文書化
   - 作業進捗に応じて影響を受けるコンポーネントセクションを更新

4. 必須セクション（順序通り）:

   - 問題分析: 明確な問題定義
   - ソリューション設計: 検討されたアプローチ
   - 実装ステップ: 詳細な分解
   - 影響を受けるコンポーネント: 影響を受けるファイル/システム
   - 依存関係: タスクの関係
   - 現在のステータス: 現在の状態のスナップショット（下部）
   - 進捗履歴: 時系列記録（下部）

5. 実装ステップ形式:

   ```markdown
   - [ ] 高レベルステップ
     - [ ] 詳細なサブタスク
     - 成功基準
     - 依存関係
   ```

6. 現在のステータス形式（下部）:

   ```markdown
   ## 現在のステータス

   ### YYYY-MM-DD HH:mm

   **ステータス**: {進行中/ブロック/完了}

   - 動作中: {現在の状態}
   - 未動作: {現在の問題}
   - ブロック問題: {ある場合}
   - 次のアクション: {直近の次のステップ}
   - 必要なドキュメント更新:
     - [ ] 機能ドキュメント変更
     - [ ] APIドキュメント更新
     - [ ] コンポーネントドキュメント修正
     - [ ] テストドキュメント更新
     - [ ] アーキテクチャドキュメント変更
   ```

   注意: ドキュメント更新セクションは、変更がドキュメントに影響する場合のみ含める。

7. 進捗履歴形式（下部）:

   ```markdown
   ## 進捗履歴

   ### YYYY-MM-DD HH:mm - {簡潔なタイトル}

   - ✓ 完了: 完了した具体的な作業
   - 🤔 決定: なぜXをYより選んだか
   - ❌ 問題: 遭遇した問題とその解決方法
   - 📚 ドキュメント: 行った、または必要なドキュメント変更
   - ⏭️ 導いた: これが可能にした/アンブロックしたこと
   ```

   注意: ドキュメントエントリ（📚）は、変更がドキュメント更新に影響する、または必要とする場合に含める。

8. タスク完了:

   - すべての実装ステップがチェック済み
   - 下部に最終ステータス更新を追加
   - 完了に移動:
     ```bash
     mv docs/working-memory/open/{task-id} docs/working-memory/done/
     ```

9. ベストプラクティス:

   - 作業開始前に下部のステータスを更新
   - 決定を下した際に文書化
   - 下部の進捗ログを更新し続ける
   - 関連する問題/PRにリンク
   - リスクのある変更にはロールバック手順を含める
   - 影響を受けるコンポーネントを参照

10. テンプレートメンテナンス:
    - 月次テンプレートレビュー
    - チームフィードバックに基づく更新
    - 例セクションを最新に保つ
    - 一般的なパターンを文書化
    - 未使用セクションを削除

## バージョン管理統合

### メモリファイルバージョン管理

1. コミットパターン:

   - メモリ関連コミットには `docs(memory)` プレフィックス
   - コミットメッセージにタスクIDを含める
   - 影響を受けるメモリタイプを参照
   - 例: `docs(memory): task-123作業メモリを更新`

2. プラン更新:

   - plan.md変更を別途コミット
   - `docs(plan)` プレフィックスを使用
   - 変更サマリーを含める
   - 例: `docs(plan): Q2プロジェクトマイルストーンを更新`

3. ドキュメント変更:
   - `docs(type)` プレフィックスを使用
   - ドキュメントタイプを指定
   - 変更範囲を含める
   - 例: `docs(tech): API認証ドキュメントを更新`

### ブランチ管理

1. メモリブランチ:

   - 形式: `docs/memory/{task-id}`
   - 短期間、タスク固有
   - タスク完了後にマージ
   - 例: `docs/memory/auth-update-20240320`

2. ドキュメントブランチ:

   - 形式: `docs/{type}/{feature}`
   - タイプ: tech, project, standards
   - 機能: 変更の特定領域
   - 例: `docs/tech/auth-flow`

3. プランブランチ:
   - 形式: `docs/plan/{milestone}`
   - 主要プラン更新に使用
   - マージ前にレビューが必要
   - 例: `docs/plan/q2-roadmap`

### バージョンタグ

1. ドキュメントリリース:

   - 形式: `docs/v{major}.{minor}`
   - Major: 破壊的変更
   - Minor: 機能追加
   - 例: `docs/v1.2`

2. メモリスナップショット:

   - 形式: `memory/{YYYY-MM}`
   - 月次スナップショット
   - 古い作業メモリをアーカイブ
   - 例: `memory/2024-03`

3. プランマイルストーン:
   - 形式: `plan/{milestone}`
   - 主要プロジェクトフェーズを追跡
   - ドキュメントバージョンにリンク
   - 例: `plan/phase-1`

## 相互参照システム

### 参照タイプ

1. タスク参照:

   - 形式: `[task-id]`
   - タスクプランへのリンク
   - 依存関係を示す
   - 例: `[auth-update-20240320]`

2. ドキュメントリンク:

   - 相対パスを使用
   - 形式: `[title](path/to/doc.md)`
   - セクションアンカーを含める
   - 例: `[認証フロー](/docs/technical/auth-flow.md#session-management)`

3. コンポーネント参照:
   - 形式: `{component-type}/{name}`
   - 実装へのリンク
   - 例: `ui/auth-form`

### 参照関係

1. タスク依存関係:

   ```markdown
   ## 依存関係

   - ブロック: [task-id-1], [task-id-2]
   - ブロック元: [task-id-3]
   - 関連: [task-id-4]
   ```

2. ドキュメント階層:

   ```markdown
   ## 関連ドキュメント

   - 親: [システム概要](/docs/system.md)
   - 子:
     - [コンポーネントA](/docs/components/a.md)
     - [コンポーネントB](/docs/components/b.md)
   ```

3. 実装リンク:

   ```markdown
   ## 実装

   - コンポーネント: {ui/auth-form}
   - テスト: {tests/auth-form.test.tsx}
   - 型: {types/auth.ts}
   ```

### 参照管理

1. リンク検証:

   - 月次で壊れたリンクを確認
   - ファイル移動時の参照更新
   - 廃止されたリンクの削除
   - パスを相対に保つ

2. 依存関係追跡:

   - 日次でタスク依存関係を更新
   - 完了した依存関係をマーク
   - ブロック関係に注意
   - 循環依存関係を追跡

3. 参照ドキュメント:
   - すべての参照タイプを文書化
   - 例を最新に保つ
   - 廃止された参照に注意
   - 参照パターンを追跡

## 観測性

### システム監視

1. パフォーマンス監視:

   - ページロード時間を追跡
   - APIレスポンス時間を監視
   - メモリ使用量を監視
   - コンポーネントレンダリング時間を追跡
   - データベースクエリを監視

2. エラー追跡:

   - クライアントサイドエラーをキャプチャ
   - API失敗を監視
   - 認証問題を追跡
   - データベースエラーをログ
   - ビルド失敗を監視

3. ユーザー分析:
   - 機能使用量を追跡
   - ユーザーフローを監視
   - パフォーマンス指標をキャプチャ
   - エラー率を追跡
   - コンバージョンパスを監視

### ログ標準

1. ログレベル:

   - debug: 開発詳細と詳細情報
   - info: 一般的な運用イベント
   - warn: 確認すべき警告状態
   - error: 即座に対処が必要なエラー状態

2. ログメソッド:

   ```typescript
   logger.debug(message: string, data?: any)
   logger.info(message: string, data?: any)
   logger.warn(message: string, data?: any)
   logger.error(message: string, error?: any, data?: any)
   ```

3. エラーハンドリング:

   ```typescript
   try {
     // 失敗する可能性のある操作
   } catch (error) {
     logger.error("操作失敗", error, { context: "追加データ" });
   }
   ```

4. 一般的なログパターン:

   ```typescript
   // 機能初期化
   logger.info("機能初期化", { featureId, config });

   // APIコール
   logger.debug("APIリクエスト", { endpoint, params });
   logger.info("APIレスポンス受信", { status, data });

   // エラーハンドリング
   logger.error("APIリクエスト失敗", error, { endpoint, params });

   // ユーザーアクション
   logger.info("ユーザーアクション", { action, userId, details });
   ```

### デバッグガイドライン

1. 開発ツール:

   - React DevToolsを使用
   - ソースマップを有効化
   - ブラウザデバッガーを使用
   - 詳細ログを有効化
   - パフォーマンスプロファイラーを使用

2. 一般的な問題:

   - コンポーネントレンダリング
   - 状態管理
   - API統合
   - 認証フロー
   - パフォーマンスボトルネック

3. デバッグプロセス:
   - 問題を再現
   - エラーログを確認
   - 最近の変更を確認
   - 分離してテスト
   - 発見事項を文書化

### アラート

1. クリティカルアラート:

   - 認証失敗
   - APIダウンタイム
   - データベースエラー
   - メモリリーク
   - ビルド失敗

2. 警告アラート:

   - 高レイテンシ
   - エラー率スパイク
   - ディスク容量不足
   - キャッシュミス
   - 低速クエリ

3. アラート管理:
   - 重要度レベルを定義
   - 閾値を設定
   - オンコールローテーションを確立
   - 対応手順を文書化
   - 解決時間を追跡

## 機能ドキュメント

### 構造

1. 場所:

   - `/docs/features/{feature-name}/`
   - 例: `/docs/features/auth/`

2. 必須ファイル:
   ```
   /docs/features/{feature-name}/
   ├── README.md           # 機能概要
   ├── architecture.md     # 技術設計
   ├── components.md       # コンポーネントドキュメント
   ├── api.md             # APIエンドポイント
   └── testing.md         # テストシナリオ
   ```

### 機能概要 (README.md)

```markdown
# {機能名}

## 概要

- 目的とゴール
- ユーザーストーリー
- 主要機能
- 依存関係

## ステータス

- 現在の状態
- 計画された改善
- 既知の制限

## クイックリンク

- [アーキテクチャ](./architecture.md)
- [コンポーネント](./components.md)
- [APIドキュメント](./api.md)
- [テスト](./testing.md)
```

### アーキテクチャドキュメント

```markdown
# {機能名} アーキテクチャ

## システム設計

- 高レベル概要
- コンポーネント関係
- データフロー図

## 技術的決定

- 技術選択
- 設計パターン
- パフォーマンス考慮事項

## 依存関係

- 外部サービス
- 内部依存関係
- 設定要件
```

### コンポーネントドキュメント

```markdown
# {機能名} コンポーネント

## コンポーネントツリー

- 親子関係
- コンポーネント階層
- 状態管理

## 個別コンポーネント

### {コンポーネント名}

- 目的
- Propsインターフェース
- 使用例
- 状態管理
- イベントハンドラー
```

### 実装ガイドライン

1. ドキュメント作成:

   - 機能ブランチで機能ディレクトリを作成
   - README.mdから開始
   - 機能開発に応じて他のドキュメントを追加
   - 図は `/assets` に保持

2. メンテナンス:

   - 重要な変更時に更新
   - 月次レビュー
   - 廃止された機能をアーカイブ
   - 機能依存関係を追跡

3. 相互参照:
   - 関連機能にリンク
   - コンポーネントを参照
   - API依存関係を文書化
   - 機能フラグを追跡

### 機能ライフサイクル

1. 計画:

   - 機能ディレクトリを作成
   - README.mdを下書き
   - アーキテクチャを定義
   - コンポーネント構造を計画

2. 開発:

   - 実装とともにドキュメントを更新
   - API変更を文書化
   - コンポーネント詳細を追加
   - コード例を含める

3. テスト:

   - テストシナリオを文書化
   - エッジケースを追加
   - パフォーマンステストを含める
   - テストデータを文書化

4. メンテナンス:
   - 機能バージョンを追跡
   - 改善を文書化
   - 廃止を記録
   - 依存関係を更新

### ドキュメント強制

1. タスク要件:

   - すべての機能タスクプランにドキュメント更新を含める必要がある
   - タスク完了前にドキュメント変更をレビューする必要がある
   - ドキュメントなしで機能を完了とマークできない
   - すべてのコンポーネント変更は対応するドキュメント更新を必要とする

2. 品質基準:

   - ドキュメントは実装と一致する必要がある
   - 例は動作し、テストされている必要がある
   - APIドキュメントは実際のエンドポイントを反映する必要がある
   - コンポーネントドキュメントは現在のインターフェースを反映する必要がある

3. レビュープロセス:
   - すべてのドキュメント変更は実装と一緒にレビューされる
   - ドキュメントは機能デモとともに検証される
   - 古いドキュメントは新しいリリースとともに更新される
   - 廃止されたドキュメントは削除またはアーカイブされる

## 日付/時刻管理

### 現在の日付/時刻の取得

1. ターミナルコマンド:
   - `date` - 現在の日付と時刻を表示
   - `date +%Y-%m-%d` - YYYY-MM-DD形式
   - `date +%Y-%m-%d_%H-%M-%S` - タイムスタンプ
   - `date +%s` - Unixタイムスタンプ

2. 時間の比較:
   - 常にターミナルコマンドを使用して現在時刻を取得
   - ログまたは実行時間を文書化するときに使用
   - タスク計画とプログレストラッキングに使用

3. 例:
   ```bash
   # 現在の日付を取得
   date +%Y-%m-%d
   
   # タスクIDに使用するタイムスタンプ
   date +%Y%m%d_%H%M
   
   # ログファイル名
   date +%Y-%m-%d
   ```

### タスクプランでの時間管理

1. タスクID形式:
   - `{feature-name}-{YYYYMMDD}`
   - 例: `auth-update-20240320`

2. ステータス更新:
   - 形式: `YYYY-MM-DD HH:mm`
   - 例: `2024-03-20 14:30`

3. 進捗履歴:
   - 各エントリに日時を含める
   - 時系列順に維持
   - 完了時間を追跡

### 時間監視

1. パフォーマンス指標:
   - API応答時間
   - ページロード時間
   - ビルド時間
   - テスト実行時間

2. 監視アラート:
   - 高レイテンシ警告
   - タイムアウト検出
   - パフォーマンス低下
   - 異常な実行時間

3. 時間ベースの自動化:
   - 定期レビュー
   - ログローテーション
   - バックアップスケジュール
   - メンテナンスウィンドウ

覚えておく:

- 常に現在の日付/時刻にはターミナルコマンドを使用
- 一貫したタイムスタンプ形式を維持
- 実行時間と完了時間を追跡
- パフォーマンス指標を時間ベースで監視
- 時間ベースの自動化を計画